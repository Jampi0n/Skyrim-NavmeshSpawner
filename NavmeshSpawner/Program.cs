using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Noggog;
using Mutagen.Bethesda.Skyrim.Records.Tooling;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Records;
using DynamicData;

namespace NavmeshSpawner {
    public enum SpawnPrevention {
        Id,
        Root,
        Faction,
        Never
    }

    public class EnemySettings {
        public int minNearby = 2;
        public double preventionFactor = 1.25;
        public bool ignoreDead = true;
        public bool spawnRoot = true;
        public SpawnPrevention spawnPrevention = SpawnPrevention.Faction;
    }
    public class Settings {
        public double minDistance = 1000;
        public double maxDistance = 10000;
        public double verticalWeight = 0.5;
        public int maxSpawnsPerNpc = 3;
        public EnemySettings enemySettings = new();
    }

    record NpcInfo(bool isValid, HashSet<FormKey> factions);
    record PlacedNpcInfo {
        public IPlacedNpcGetter placedNpc { get; init; }
        public int allowedSpawns { get; set; }

        public PlacedNpcInfo(IPlacedNpcGetter placedNpc, int allowedSpawns) {
            this.placedNpc = placedNpc;
            this.allowedSpawns = allowedSpawns;
        }
    };
    public class Program {

        static Lazy<Settings> _Settings = null!;
        public static Settings Settings => _Settings.Value;

        public static async Task<int> Main(string[] args) {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out _Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "NavmeshSpawner.esp")
                .Run(args);
        }

        private static bool NpcIsValidSpawnRec(INpcSpawnGetter npcSpawnGetter, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache, bool containsLeveledChar) {
            if (npcSpawnGetter is INpcGetter npcGetter) {
                if (!npcGetter.Template.IsNull) {
                    if (npcGetter.Template.TryResolve(linkCache, out var template)) {
                        return NpcIsValidSpawnRec(template, linkCache, containsLeveledChar);
                    }
                } else {
                    var flags = npcGetter.Configuration.Flags;
                    return containsLeveledChar && !flags.HasFlag(NpcConfiguration.Flag.Unique) && !flags.HasFlag(NpcConfiguration.Flag.Essential) && flags.HasFlag(NpcConfiguration.Flag.Respawn);
                }
            }
            if (npcSpawnGetter is ILeveledNpcGetter leveledNpcGetter) {
                if (leveledNpcGetter.Entries != null && leveledNpcGetter.Entries.Count > 0) {
                    var data = leveledNpcGetter.Entries[0].Data;
                    if (data != null && data.Reference.TryResolve(linkCache, out var reference)) {
                        return NpcIsValidSpawnRec(reference, linkCache, true);
                    }
                }
            }
            return false;
        }

        private static bool NpcIsValidSpawn(INpcSpawnGetter npcSpawnGetter, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache) {
            return NpcIsValidSpawnRec(npcSpawnGetter, linkCache, false);
        }

        private static HashSet<FormKey> GetFactions(INpcSpawnGetter npcSpawnGetter, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache) {
            if (npcSpawnGetter is INpcGetter npcGetter) {
                if (npcGetter.Configuration.TemplateFlags.HasFlag(NpcConfiguration.TemplateFlag.Factions)) {
                    if (npcGetter.Template.TryResolve(linkCache, out var template)) {
                        return GetFactions(template, linkCache);
                    }
                } else {
                    return npcGetter.Factions.Select(faction => faction.Faction.FormKey).ToHashSet();
                }
            }
            if (npcSpawnGetter is ILeveledNpcGetter leveledNpcGetter) {
                if (leveledNpcGetter.Entries != null && leveledNpcGetter.Entries.Count > 0) {
                    var data = leveledNpcGetter.Entries[0].Data;
                    if (data != null && data.Reference.TryResolve(linkCache, out var reference)) {
                        return GetFactions(reference, linkCache);
                    }
                }
            }
            return [];
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            int counter = 0;
            var worldspaceCellLocation = new WorldspaceCellLocationCache(state.LoadOrder.PriorityOrder.Cell().WinningContextOverrides(state.LinkCache));
            var npcsByCell = new Dictionary<IModContext<ISkyrimMod, ISkyrimModGetter, ICell, ICellGetter>, List<IPlacedNpcGetter>>();
            var npcInfoDict = new Dictionary<FormKey, NpcInfo>();
            foreach (var placedNpcContext in state.LoadOrder.PriorityOrder.PlacedNpc().WinningContextOverrides(state.LinkCache)) {

                if (placedNpcContext.Record.Placement == null) {
                    continue;
                }

                if (placedNpcContext.TryGetContainingCell(worldspaceCellLocation, out var containingCell)) {
                    if (!npcsByCell.TryGetValue(containingCell, out List<IPlacedNpcGetter>? value)) {
                        value = new List<IPlacedNpcGetter>();
                        npcsByCell.Add(containingCell, value);
                    }

                    value.Add(placedNpcContext.Record);
                }
            }


            foreach (var kv in npcsByCell) {
                var pointList = new List<P3Float>();
                var cellContext = kv.Key;
                var cellRecord = cellContext.Record;

                foreach (var navMesh in cellRecord.NavigationMeshes) {
                    if (navMesh.Data == null) {
                        continue;
                    }
                    var vertexArray = navMesh.Data.Vertices.ToArray();
                    foreach (var triangle in navMesh.Data.Triangles) {
                        var a = vertexArray[triangle.Vertices.X];
                        var b = vertexArray[triangle.Vertices.Y];
                        var c = vertexArray[triangle.Vertices.Z];
                        pointList.Add(new P3Float((a.X + b.X + c.X) / 3, (a.Y + b.Y + c.Y) / 3, (a.Z + b.Z + c.Z) / 3));
                    }
                }

                if (pointList.Count > 0) {
                    ICell? cellCopy = null;

                    var placedNpcs = kv.Value
                        .Where(npc => !Settings.enemySettings.ignoreDead || !npc.MajorFlags.HasFlag(PlacedNpc.MajorFlag.StartsDead))
                        .Select(npc => new PlacedNpcInfo(npc, Settings.maxSpawnsPerNpc)).ToList();


                    foreach (var placedNpc in placedNpcs) {
                        var key = placedNpc.placedNpc.Base.FormKey;
                        if (!npcInfoDict.ContainsKey(key)) {
                            if (placedNpc.placedNpc.Base.TryResolve(state.LinkCache, out var npc)) {
                                npcInfoDict.Add(key, new NpcInfo(NpcIsValidSpawn(npc, state.LinkCache), GetFactions(npc, state.LinkCache)));
                            } else {
                                npcInfoDict.Add(key, new NpcInfo(false, new HashSet<FormKey>()));
                            }
                        }
                    }



                    foreach (var point in pointList) {

                        var nearbyNpcs = new List<PlacedNpcInfo>();
                        var preventionNpcs = new List<PlacedNpcInfo>();

                        var valid = true;
                        PriorityQueue<PlacedNpcInfo, double> closestNpcs = new();

                        foreach (var placedNpc in placedNpcs) {
                            var pos1 = placedNpc.placedNpc.Placement!.Position * 1;
                            var pos2 = point * 1;
                            pos1.Z *= (float)Settings.verticalWeight;
                            pos2.Z *= (float)Settings.verticalWeight;
                            var distance = (pos1 - pos2).Magnitude;
                            if (distance < Settings.minDistance) {
                                valid = false;
                                break;
                            }
                            if (distance <= Settings.maxDistance) {
                                closestNpcs.Enqueue(placedNpc, distance);
                            }
                        }

                        if (closestNpcs.Count < Settings.enemySettings.minNearby) {
                            continue;
                        }
                        var closestNpc = closestNpcs.Peek();
                        var closestBaseNpc = closestNpc.placedNpc.Base;
                        var closestNpcInfo = npcInfoDict[closestBaseNpc.FormKey];
                        if (!closestNpcInfo.isValid || closestNpc.placedNpc.MajorFlags.HasFlag(PlacedNpc.MajorFlag.StartsDead) || closestNpc.placedNpc.MajorFlags.HasFlag(PlacedNpc.MajorFlag.Persistent)) {
                            continue;
                        }

                        var missing = Settings.enemySettings.minNearby;
                        while (missing > 1) {
                            nearbyNpcs.Add(closestNpcs.Dequeue());
                            missing--;
                        }
                        if (closestNpcs.TryDequeue(out var farthestConsidered, out var farthestDistance)) {

                            if (Settings.enemySettings.spawnPrevention != SpawnPrevention.Never) {
                                foreach (var placedNpc in placedNpcs) {
                                    var pos1 = placedNpc.placedNpc.Placement!.Position * 1;
                                    var pos2 = point * 1;
                                    pos1.Z *= (float)Settings.verticalWeight;
                                    pos2.Z *= (float)Settings.verticalWeight;
                                    var distance = (pos1 - pos2).Magnitude;
                                    if (distance <= farthestDistance * Settings.enemySettings.preventionFactor) {
                                        var preventationNpcInfo = npcInfoDict[placedNpc.placedNpc.Base.FormKey];
                                        if (Settings.enemySettings.spawnPrevention == SpawnPrevention.Faction) {
                                            if (!closestNpcInfo.factions.Intersect(preventationNpcInfo.factions).Any()) {
                                                valid = false;
                                                break;
                                            }
                                        } else if (Settings.enemySettings.spawnPrevention == SpawnPrevention.Id) {
                                            if (closestBaseNpc.FormKey != placedNpc.placedNpc.Base.FormKey) {
                                                valid = false;
                                                break;
                                            }
                                        } else if (Settings.enemySettings.spawnPrevention == SpawnPrevention.Root) {
                                            // not implemented
                                        }
                                    }
                                }

                                if (valid) {
                                    var newNpc = new PlacedNpc(state.PatchMod);
                                    newNpc.DeepCopyIn(closestNpc.placedNpc);
                                    newNpc.LevelModifier = closestNpc.placedNpc.LevelModifier;
                                    newNpc.LinkedReferences.Clear();
                                    newNpc.Placement = new Placement() {
                                        Position = point
                                    };
                                    closestNpc.allowedSpawns--;
                                    if (cellCopy == null) {
                                        cellCopy = cellContext.GetOrAddAsOverride(state.PatchMod);
                                    }
                                    cellCopy.Temporary.Add(newNpc);
                                    placedNpcs.Add(new PlacedNpcInfo(newNpc, 0));
                                    counter++;
                                }
                            }
                        }
                    }
                }
            }
            Console.WriteLine(counter);
        }
    }
}